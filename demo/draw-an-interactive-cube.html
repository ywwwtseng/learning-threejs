<!DOCTYPE html>
<html>
  <head>
    <title>Draw an interactive cube</title>

    <style>
      html, body {
        height: 100%;
      }

      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

    </style>
  </head>
  <body>
    <script>
      // mat4
      var mat4 = {}

      mat4.toI4 = function(matrix) {
        matrix[0] = 1, matrix[1] = 0, matrix[2] = 0, matrix[3] = 0,
        matrix[4] = 0, matrix[5] = 1, matrix[6] = 0, matrix[7] = 0,
        matrix[8] = 0, matrix[9] = 0, matrix[10] = 1, matrix[11] = 0,
        matrix[12] = 0, matrix[13] = 0, matrix[14] = 0, matrix[15] = 1;
      }

      mat4.rotateX = function (m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv1 = m[1], mv5 = m[5], mv9 = m[9];

        m[1] = m[1]*c - m[2]*s;
        m[5] = m[5]*c - m[6]*s;
        m[9] = m[9]*c - m[10]*s;

        m[2] = m[2]*c + mv1*s;
        m[6] = m[6]*c + mv5*s;
        m[10] = m[10]*c + mv9*s;
      }

      mat4.rotateY = function (m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv0 = m[0], mv4 = m[4], mv8 = m[8];

        m[0] = c*m[0] + s*m[2];
        m[4] = c*m[4] + s*m[6];
        m[8] = c*m[8] + s*m[10];

        m[2] = c*m[2] - s*mv0;
        m[6] = c*m[6] - s*mv4;
        m[10] = c*m[10] - s*mv8;
      }

      mat4.rotate = function(m, angleX, angleY, angleZ) {
        if (angleY) { mat4.rotateY(m, angleY); }
        if (angleX) { mat4.rotateX(m, angleX); }
      }
    </script>
    <script>
      var THREE = {};

      THREE.WebGLRenderer = function () {
        this.domElement = document.createElement("canvas");
        this.domElement.id = "canvas";
        this.domElement.width = "570";
        this.domElement.height = "570";

        this.setSize = function (width, height) {
          this.domElement.width = width;
          this.domElement.height = height;
        }

        var _gl = this.domElement.getContext("webgl");
      }

      // var renderer = new THREE.WebGLRenderer();
      // renderer.setSize(window.innerWidth, window.innerHeight);
      // document.body.prepend(renderer.domElement);
    </script>
    <script>
      var canvas = createCanvas();
      document.body.prepend(canvas);

      /**
       *  The WebGL context
       * 
       *  The state of WebGL were stored in the context, such as Buffers, Framebuffers, Renderbuffers and Textures.
       *  The WebGL context provide javascript API to deal with them.
       */
      var gl = canvas.getContext("webgl");

      var vertices = [
        -1,-1,-1,     1,-1,-1,     1, 1,-1,    -1, 1,-1, // Back face vertices
        -1,-1, 1,     1,-1, 1,     1, 1, 1,    -1, 1, 1, // Front face vertices
        -1,-1,-1,    -1, 1,-1,    -1, 1, 1,    -1,-1, 1, // Left Face vertices
         1,-1,-1,     1, 1,-1,     1, 1, 1,     1,-1, 1, // Right Face vertices
        -1,-1,-1,    -1,-1, 1,     1,-1, 1,     1,-1,-1, // Bottom Face vertices
        -1, 1,-1,    -1, 1, 1,     1, 1, 1,     1, 1,-1, // Top Face vertices
      ];
      var colors = [
         0, 0, 0,     0, 0, 0,     0, 0, 0,     0, 0, 0, // Back face color - Black
         1, 1, 1,     1, 1, 1,     1, 1, 1,     1, 1, 1, // Front face color - white
         0, 0, 1,     0, 0, 1,     0, 0, 1,     0, 0, 1, // Left Face color - Blue
         1, 0, 0,     1, 0, 0,     1, 0, 0,     1, 0, 0, // Right Face color - Red
         1, 1, 0,     1, 1, 0,     1, 1, 0,     1, 1, 0, // Bottom Face color - Yellow
         0, 1, 0,     0, 1, 0,     0, 1, 0,     0, 1, 0, // Top Face color - Green
      ];
      var indices = [
         0, 1, 2,     0, 2, 3, // Back face indices
         4, 5, 6,     4, 6, 7, // Front face indices
         8, 9,10,     8,10,11, // Left Face indices
         12,13,14,    12,14,15, // Right Face indices
         16,17,18,    16,18,19, // Bottom Face indices
         20,21,22,    20,22,23, // Top Face indices
      ];

      var createWebGLBuffer = CreateWebGLBuffer(gl);
      var vertexBuffer = createWebGLBuffer(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      var colorBuffer = createWebGLBuffer(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      var indexBuffer = createWebGLBuffer(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

      /**
       * GLSL（OpenGL Shading Language）
       */

      var shaderProgram = CreateShaderProgram(gl)({
        vertexShader: 
        `
        attribute vec3 position;
        uniform mat4 Pmatrix;
        uniform mat4 Vmatrix;
        uniform mat4 Mmatrix;
        attribute vec3 color;
        varying vec3 vColor;

        void main(void) {
          gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
          vColor = color;
        }
        `,
        fragmentShader: 
        `
        precision mediump float;
        varying vec3 vColor;

        void main(void) {
          gl_FragColor = vec4(vColor, 1.);
        }
        `,
      });

      /*======== Associating buffer object to vertex shader =====*/
      var _Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
      var _Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
      var _Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      var _position = gl.getAttribLocation(shaderProgram, "position");
      gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.enableVertexAttribArray(_position);

      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      var _color = gl.getAttribLocation(shaderProgram, "color");
      gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.enableVertexAttribArray(_color);

      gl.useProgram(shaderProgram);

      /*======== MATRIX =========================================*/

      // Camera
      var projectionMatrix = createProjectionMatrix(40, canvas.width/canvas.height, 1, 100);
      var viewMatrix = [
        1,    0,    0,    0,
        0,    1,    0,    0, 
        0,    0,    1,    0, 
        0,    0,    0,    1,
      ];

      viewMatrix[14] = viewMatrix[14] - 6; // translating z

      var modelViewMatrix = [
        1,    0,    0,    0, 
        0,    1,    0,    0,
        0,    0,    1,    0, 
        0,    0,    0,    1,
      ];

      /*======== ANIMATION ======================================*/
      var AMORTIZATION = 0.95;
      var THETA = 0;
      var PHI = 0;
      var time_old = 0;

      var mouse = new Mouse({target: canvas});
      mouse.addEventListener("move", function(dX, dY) {
        THETA += dX;
        PHI += dY;
      });

      animate(0);
      
      function animate(time) {
        var dt = time - time_old;

        if (!mouse.isDrag) {
          mouse.dX *= AMORTIZATION, mouse.dY *= AMORTIZATION;
          THETA += mouse.dX, PHI += mouse.dY;
        }

        mat4.toI4(modelViewMatrix);
        mat4.rotate(modelViewMatrix, PHI, THETA, 0);

        time_old = time;
        gl.enable(gl.DEPTH_TEST);
        // gl.depthFunc(gl.LEQUAL);

        gl.clearColor(0.5, 0.5, 0.5, 0.9);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.viewport(0.0, 0.0, canvas.width, canvas.height);

        gl.uniformMatrix4fv(_Pmatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(_Vmatrix, false, viewMatrix);
        gl.uniformMatrix4fv(_Mmatrix, false, modelViewMatrix);
        
        // Tell WebGL which indices to use to index the vertices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        window.requestAnimationFrame(animate);
      }

      function createCanvas() {
        var canvas = document.createElement("canvas");
        canvas.id = "canvas";
        canvas.width = "570";
        canvas.height = "570";

        return canvas;
      }

      function CreateWebGLBuffer(gl) {
        return function(target, size, usage) {
          var buffer = gl.createBuffer();
          gl.bindBuffer(target, buffer);
          gl.bufferData(target, size, usage);
          gl.bindBuffer(target, null);

          return buffer;
        }
      }

      function CreateShader(gl) {
        return function(shaderType, code) {
          var ShaderType = {
            vertex: gl.VERTEX_SHADER,
            fragment: gl.FRAGMENT_SHADER,
          };

          var shader = gl.createShader(ShaderType[shaderType]);
          gl.shaderSource(shader, code);
          gl.compileShader(shader);

          return shader;
        }
      }

      function CreateShaderProgram(gl) {
        return function(options) {
          var createShader = CreateShader(gl);
          var vertexShader = createShader("vertex", options.vertexShader);
          var fragmentShader = createShader("fragment", options.fragmentShader);

          var shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vertexShader);
          gl.attachShader(shaderProgram, fragmentShader);
          gl.linkProgram(shaderProgram);

          return shaderProgram;
        }
      }

      function createProjectionMatrix(angle, a, zMin, zMax) {
        var ang = Math.tan((angle * .5) * Math.PI / 180);

        return [
          0.5/ang,         0,                          0,  0,
                0, 0.5*a/ang,                          0,  0,
                0,         0,   -(zMax+zMin)/(zMax-zMin), -1,
                0,         0, (-2*zMax*zMin)/(zMax-zMin),  0,
        ];
      }

      function Mouse(options) {
        var self = this;
        var oldX, oldY;

        self.isDrag = false;
        self.dX = 0;
        self.dY = 0;
        self.events = {};

        self.addEventListener = function(type, listener) {
          self.events[type] = listener
        }

        options.target.addEventListener("mousedown", mouseDown, false);
        options.target.addEventListener("mouseup", mouseUp, false);
        options.target.addEventListener("mouseout", mouseUp, false);
        options.target.addEventListener("mousemove", mouseMove, false);

        function mouseDown(e) {
          self.isDrag = true;
          oldX = e.pageX, oldY = e.pageY;
          e.preventDefault();
          return false;
        }

        function mouseUp(e) {
          self.isDrag = false;
        }

        function mouseMove(e) {
          if (!self.isDrag) return false;

          self.dX = (e.pageX - oldX)*2*Math.PI/canvas.width;
          self.dY = (e.pageY - oldY)*2*Math.PI/canvas.height;

          if (self.events.move) { self.events.move(self.dX, self.dY); }
          oldX = e.pageX, oldY = e.pageY;
          e.preventDefault();
        }
      }
    </script>
  </body>
</html>
