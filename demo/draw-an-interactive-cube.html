<!DOCTYPE html>
<html>
  <head>
    <title>Draw an interactive cube</title>

    <style>
      html, body {
        height: 100%;
      }

      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

    </style>
  </head>
  <body>
    <script>
      var canvas = createCanvas();
      document.body.prepend(canvas);

      /**
       *  The WebGL context
       * 
       *  The state of WebGL were stored in the context, such as Buffers, Framebuffers, Renderbuffers and Textures.
       *  The WebGL context provide javascript API to deal with them.
       */
      var gl = getWebGLRenderingContext(canvas);

      var Cube = {
        vertices: [
          -1,-1,-1,     1,-1,-1,     1, 1,-1,    -1, 1,-1,
          -1,-1, 1,     1,-1, 1,     1, 1, 1,    -1, 1, 1,
          -1,-1,-1,    -1, 1,-1,    -1, 1, 1,    -1,-1, 1,
           1,-1,-1,     1, 1,-1,     1, 1, 1,     1,-1, 1,
          -1,-1,-1,    -1,-1, 1,     1,-1, 1,     1,-1,-1,
          -1, 1,-1,    -1, 1, 1,     1, 1, 1,     1, 1,-1,
        ],
        colors: [
           5, 3, 7,     5, 3, 7,     5, 3, 7,     5, 3, 7,
           1, 1, 3,     1, 1, 3,     1, 1, 3,     1, 1, 3,
           0, 0, 1,     0, 0, 1,     0, 0, 1,     0, 0, 1,
           1, 0, 0,     1, 0, 0,     1, 0, 0,     1, 0, 0,
           1, 1, 0,     1, 1, 0,     1, 1, 0,     1, 1, 0,
           0, 1, 0,     0, 1, 0,     0, 1, 0,     0, 1, 0,
        ],
        indices: [
           0, 1, 2,     0, 2, 3,     4, 5, 6,     4, 6, 7,
           8, 9,10,     8,10,11,    12,13,14,    12,14,15,
          16,17,18,    16,18,19,    20,21,22,    20,22,23,
        ],
      };

      var createBufferObject = CreateBufferObject(gl);
      var vertexBuffer = createBufferObject(gl.ARRAY_BUFFER, new Float32Array(Cube.vertices), gl.STATIC_DRAW);
      var colorBuffer = createBufferObject(gl.ARRAY_BUFFER, new Float32Array(Cube.colors), gl.STATIC_DRAW);
      var indexBuffer = createBufferObject(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(Cube.indices), gl.STATIC_DRAW);

      var shaderProgram = CreateShaderProgram(gl)({
        vertexShader: 
        `
        attribute vec3 position;
        uniform mat4 Pmatrix;
        uniform mat4 Vmatrix;
        uniform mat4 Mmatrix;
        attribute vec3 color;
        varying vec3 vColor;

        void main(void) {
          gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
          vColor = color;
        }
        `,
        fragmentShader: 
        `
        precision mediump float;
        varying vec3 vColor;

        void main(void) {
          gl_FragColor = vec4(vColor, 1.);
        }
        `,
      });

      /*======== Associating buffer object to vertex shader =====*/
      var _Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
      var _Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
      var _Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      var _position = gl.getAttribLocation(shaderProgram, "position");
      gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(_position);

      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      var _color = gl.getAttribLocation(shaderProgram, "color");
      gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(_color);

      gl.useProgram(shaderProgram);

      /*======== MATRIX =========================================*/
      var projectionMatrix = createProjectionMatrix(40, canvas.width/canvas.height, 1, 100);
      var modelViewMatrix = [
        1,    0,    0,    0, 
        0,    1,    0,    0, 
        0,    0,    1,    0, 
        0,    0,    0,    1,
      ];
      var viewMatrix = [
        1,    0,    0,    0, 
        0,    1,    0,    0, 
        0,    0,    1,    0, 
        0,    0,    0,    1,
      ];

      // translating z
      viewMatrix[14] = viewMatrix[14] - 6; //zoom

      var AMORTIZATION = 0.95;
      var THETA = 0;
      var PHI = 0;
      var time_old = 0;

      var mouse = new Mouse({target: canvas});
      mouse.move = function(dX, dY) {
        THETA += dX;
        PHI +=dY;
      }

      animate(0);
      
      function animate(time) {
        var dt = time - time_old;

        if (!mouse.isDrag) {
            mouse.dX *= AMORTIZATION, mouse.dY *= AMORTIZATION;
            THETA += mouse.dX, PHI += mouse.dY;
        }

        // set model matrix to I4

        modelViewMatrix[0] = 1, modelViewMatrix[1] = 0, modelViewMatrix[2] = 0,
        modelViewMatrix[3] = 0,

        modelViewMatrix[4] = 0, modelViewMatrix[5] = 1, modelViewMatrix[6] = 0,
        modelViewMatrix[7] = 0,

        modelViewMatrix[8] = 0, modelViewMatrix[9] = 0, modelViewMatrix[10] = 1,
        modelViewMatrix[11] = 0,

        modelViewMatrix[12] = 0, modelViewMatrix[13] = 0, modelViewMatrix[14] = 0,
        modelViewMatrix[15] = 1;

        rotateY(modelViewMatrix, THETA);
        rotateX(modelViewMatrix, PHI);

        time_old = time; 
        gl.enable(gl.DEPTH_TEST);
        // gl.depthFunc(gl.LEQUAL);

        gl.clearColor(0.5, 0.5, 0.5, 0.9);
        gl.clearDepth(1.0);
        gl.viewport(0.0, 0.0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.uniformMatrix4fv(_Pmatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(_Vmatrix, false, viewMatrix);
        gl.uniformMatrix4fv(_Mmatrix, false, modelViewMatrix);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, Cube.indices.length, gl.UNSIGNED_SHORT, 0);

        window.requestAnimationFrame(animate);
      }

      function createCanvas() {
        var canvas = document.createElement("canvas");
        canvas.id = "canvas";
        canvas.width = "570";
        canvas.height = "570";

        return canvas;
      }

      function getWebGLRenderingContext(canvas) {
        return canvas.getContext("webgl");
      }

      function CreateBufferObject(gl) {
        return function(target, size, usage) {
          var buffer = gl.createBuffer();
          gl.bindBuffer(target, buffer);
          gl.bufferData(target, size, usage);

          return buffer;
        }
      }

      function CreateShader(gl) {
        return function(shaderType, code) {
          var ShaderType = {
            vertex: gl.VERTEX_SHADER,
            fragment: gl.FRAGMENT_SHADER,
          };

          var shader = gl.createShader(ShaderType[shaderType]);
          gl.shaderSource(shader, code);
          gl.compileShader(shader);

          return shader;
        }
      }

      function CreateShaderProgram(gl) {
        return function(options) {
          var createShader = CreateShader(gl);
          var vertexShader = createShader("vertex", options.vertexShader);
          var fragmentShader = createShader("fragment", options.fragmentShader);

          var shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vertexShader);
          gl.attachShader(shaderProgram, fragmentShader);
          gl.linkProgram(shaderProgram);

          return shaderProgram;
        }
      }

      function createProjectionMatrix(angle, a, zMin, zMax) {
        var ang = Math.tan((angle * .5) * Math.PI / 180);

        return [
          0.5/ang,         0,                          0,  0,
                0, 0.5*a/ang,                          0,  0,
                0,         0,   -(zMax+zMin)/(zMax-zMin), -1,
                0,         0, (-2*zMax*zMin)/(zMax-zMin),  0,
        ];
      }

      function Mouse(options) {
        var self = this;
        var oldX, oldY;

        self.isDrag = false;
        self.dX = 0;
        self.dY = 0;

        options.target.addEventListener("mousedown", mouseDown, false);
        options.target.addEventListener("mouseup", mouseUp, false);
        options.target.addEventListener("mouseout", mouseUp, false);
        options.target.addEventListener("mousemove", mouseMove, false);

        function mouseDown(e) {
          self.isDrag = true;
          oldX = e.pageX, oldY = e.pageY;
          e.preventDefault();
          return false;
        }

        function mouseUp(e) {
          self.isDrag = false;
        }

        function mouseMove(e) {
          if (!self.isDrag) return false;
          
          self.dX = (e.pageX - oldX)*2*Math.PI/canvas.width;
          self.dY = (e.pageY - oldY)*2*Math.PI/canvas.height;

          if (self.move) { self.move(self.dX, self.dY); }
          oldX = e.pageX, oldY = e.pageY;
          e.preventDefault();
        }
      }

      function rotateX(m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv1 = m[1], mv5 = m[5], mv9 = m[9];

        m[1] = m[1]*c - m[2]*s;
        m[5] = m[5]*c - m[6]*s;
        m[9] = m[9]*c - m[10]*s;

        m[2] = m[2]*c + mv1*s;
        m[6] = m[6]*c + mv5*s;
        m[10] = m[10]*c + mv9*s;
      }

      function rotateY(m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv0 = m[0], mv4 = m[4], mv8 = m[8];

        m[0] = c*m[0] + s*m[2];
        m[4] = c*m[4] + s*m[6];
        m[8] = c*m[8] + s*m[10];

        m[2] = c*m[2] - s*mv0;
        m[6] = c*m[6] - s*mv4;
        m[10] = c*m[10] - s*mv8;
      }
    </script>
  </body>
</html>
